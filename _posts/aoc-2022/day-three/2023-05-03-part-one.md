---
title: Day 3 - Part One
toc: true
mermaid: true
date: 2023-05-03 12:30:00 +02
categories: [Advent of Code 2022, Day Three]
permalink: advent-of-code-2022/day-three/part-one
tags: [advent of code, kotlin, solution]
---

## Preface

Now that we have the following data structure from our [previous post](./2023-04-26-sanitizer.md), we can start by thinking about the business logic to retrieve the code that's inside all the rucksacks.

The data structure our sanitizer provides, looks like this.

```kotlin
[
    { "vJrwpWtwJgWr"    , "hcsFMMfFFhFp"     }, // Rucksack 1
    { "jqHRNqRjqzjGDLGL", "rsFMfFZSrLrFZsSL" }, // Rucksack 2
    { "PmmdzqPrV"       , "vPwwTWBwg"        }, // Rucksack 3
    { "wMqvLMZHhHMvwLH" , "jbvcjnnSBnvTQFn"  }, // Rucksack 4
    { "ttgJtRGJ"        , "QctTZtZT"         }, // Rucksack 5
    { "CrZsJsPPZsGz"    , "wwsLwLmpwMDw"     }  // Rucksack 6
]
```

## Design

So now that we have our rucksacks with each compartment seperated, we can think about how we want to setup our business logic. So to retrieve the code from all the rucksacks, we need to get the unique character that's present in both compartments.

So functionally, our design will look something like this.

```mermaid
flowchart LR

    subgraph rsOne["Rucksack One"]
        direction LR

        rsOneCompartmentOne["vJrwpWtwJgWr"]
        rsOneCompartmentTwo["hcsFMMfFFhFp"]
    end

    subgraph rsTwo["Rucksack Two"]
        direction LR

        rsTwoCompartmentOne["jqHRNqRjqzjGDLGL"]
        rsTwoCompartmentTwo["rsFMfFZSrLrFZsSL"]
    end

    subgraph rsThree["Rucksack Three"]
        direction LR

        rsThreeCompartmentOne["PmmdzqPrV"]
        rsThreeCompartmentTwo["vPwwTWBwg"]
    end

    subgraph rsFour["Rucksack Four"]
        direction LR

        rsFourCompartmentOne["wMqvLMZHhHMvwLH"]
        rsFourCompartmentTwo["jbvcjnnSBnvTQFn"]
    end

    subgraph rsFive["Rucksack Five"]
        direction LR

        rsFiveCompartmentOne["ttgJtRGJ"]
        rsFiveCompartmentTwo["QctTZtZT"]
    end

    subgraph rsSix["Rucksack Six"]
        direction LR

        rsSixCompartmentOne["CrZsJsPPZsGz"]
        rsSixCompartmentTwo["wwsLwLmpwMDw"]
    end


    findCharacter["FindMatchingCharacter()"]
    rsOneMatchingCharacter["p"]
    rsTwoMatchingCharacter["L"]
    rsThreeMatchingCharacter["P"]
    rsFourMatchingCharacter["v"]
    rsFiveMatchingCharacter["t"]
    rsSixMatchingCharacter["s"]

    rsOneCompartmentOne --> findCharacter
    rsOneCompartmentTwo --> findCharacter

    rsTwoCompartmentOne --> findCharacter
    rsTwoCompartmentTwo --> findCharacter

    rsThreeCompartmentOne --> findCharacter
    rsThreeCompartmentTwo --> findCharacter

    rsFourCompartmentOne --> findCharacter
    rsFourCompartmentTwo --> findCharacter

    rsFiveCompartmentOne --> findCharacter
    rsFiveCompartmentTwo --> findCharacter

    rsSixCompartmentOne --> findCharacter
    rsSixCompartmentTwo --> findCharacter

    findCharacter --> rsOneMatchingCharacter
    findCharacter --> rsTwoMatchingCharacter
    findCharacter --> rsThreeMatchingCharacter
    findCharacter --> rsFourMatchingCharacter
    findCharacter --> rsFiveMatchingCharacter
    findCharacter --> rsSixMatchingCharacter
```

So in our design we identity which character is present in both compartments and use that as output.

## Implementation

### Business logic

Now we know what we want our code to do, letâ€™s start implementing it in our PartOne class.

```kotlin
class PartOne(
    private val sanitizer: Sanitizer
) {
    fun getResult(): String {
        val data = sanitizer.getItems()
        
        // TODO
    }
}
```
{: file="aoc-2022/day3/src/main/kotlin/aoc/PartOne.kt" }

### Test case



```kotlin
// TODO
```
{: file="aoc-2022/day3/src/test/kotlin/aoc/PartOne.kt" }
